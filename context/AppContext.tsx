
import React, { createContext, useState, useEffect, useCallback, ReactNode } from 'react';
// FIX: Imported BookingStatus to use enum value for type safety.
import { User, Business, Booking, UserRole, BookingStatus } from '../types';
import { api } from '../services/mockApiService';
import { USERS } from '../constants';
import toast from 'react-hot-toast';

interface AppContextType {
  currentUser: User;
  businesses: Business[];
  bookings: Booking[];
  isLoading: boolean;
  switchUser: (userId: string) => void;
  addBooking: (booking: Omit<Booking, 'id' | 'createdAt' | 'status'>) => Promise<Booking | null>;
  cancelBooking: (bookingId: string) => Promise<void>;
  // FIX: A new business rating is generated by the API, so it should not be required on creation.
  addBusiness: (business: Omit<Business, 'id' | 'ownerId' | 'rating' | 'plan' | 'monthlyBookingQuota'>) => Promise<Business | null>;
  updateBusiness: (business: Business) => Promise<Business | null>;
  fetchBusinessById: (id: string) => Promise<Business | null>;
  getBusinessForOwner: (ownerId: string) => Business | undefined;
}

export const AppContext = createContext<AppContextType | undefined>(undefined);

interface AppProviderProps {
    children: ReactNode;
}

export const AppProvider: React.FC<AppProviderProps> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User>(USERS['client1']);
  const [businesses, setBusinesses] = useState<Business[]>([]);
  const [bookings, setBookings] = useState<Booking[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    try {
      const [bizData, bookingData] = await Promise.all([
        api.getBusinesses(),
        api.getBookings(),
      ]);
      setBusinesses(bizData);
      setBookings(bookingData);
    } catch (error) {
      console.error("Failed to fetch data", error);
      toast.error("Could not load app data.");
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const switchUser = (userId: string) => {
    const user = USERS[userId];
    if (user) {
      setCurrentUser(user);
      toast.success(`Switched to ${user.name} (${user.role.toLowerCase()})`);
    }
  };

  const addBooking = async (bookingData: Omit<Booking, 'id' | 'createdAt' | 'status'>) => {
    setIsLoading(true);
    try {
      const newBooking = await api.createBooking(bookingData);
      setBookings(prev => [...prev, newBooking]);
      toast.success('Reservation confirmed!');
      return newBooking;
    } catch (error: any) {
      console.error("Failed to create booking", error);
      toast.error(error.message || 'Failed to make reservation.');
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const cancelBooking = async (bookingId: string) => {
    setIsLoading(true);
    try {
      await api.cancelBooking(bookingId);
      // FIX: Used BookingStatus.CANCELLED enum member for type safety.
      setBookings(prev => prev.map(b => b.id === bookingId ? { ...b, status: BookingStatus.CANCELLED } : b));
      toast.success('Reservation cancelled.');
    } catch (error) {
      console.error("Failed to cancel booking", error);
      toast.error('Failed to cancel reservation.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // FIX: A new business rating is generated by the API, so it should not be required on creation.
  const addBusiness = async (businessData: Omit<Business, 'id'|'ownerId'|'rating'| 'plan' | 'monthlyBookingQuota'>) => {
    if (currentUser.role !== UserRole.BUSINESS_OWNER) return null;
    setIsLoading(true);
    try {
      const newBusiness = await api.createBusiness({...businessData, ownerId: currentUser.id});
      setBusinesses(prev => [...prev, newBusiness]);
      // Also update the current user to link to the new business
      const updatedUser = { ...currentUser, businessId: newBusiness.id };
      setCurrentUser(updatedUser);
      USERS[currentUser.id] = updatedUser; // Persist for session
      toast.success('Business registered successfully!');
      return newBusiness;
    } catch (error) {
      console.error("Failed to create business", error);
      toast.error('Failed to register business.');
      return null;
    } finally {
      setIsLoading(false);
    }
  }
  
  const updateBusiness = async (businessData: Business) => {
    setIsLoading(true);
    try {
      const updatedBusiness = await api.updateBusiness(businessData);
      setBusinesses(prev => prev.map(b => b.id === updatedBusiness.id ? updatedBusiness : b));
      toast.success('Profile updated successfully!');
      return updatedBusiness;
    } catch (error) {
      console.error("Failed to update business", error);
      toast.error('Failed to update profile.');
      return null;
    } finally {
      setIsLoading(false);
    }
  }

  const fetchBusinessById = async (id: string) => {
      return api.getBusinessById(id);
  };

  const getBusinessForOwner = (ownerId: string) => {
    return businesses.find(b => b.ownerId === ownerId);
  }

  return (
    <AppContext.Provider value={{ currentUser, businesses, bookings, isLoading, switchUser, addBooking, cancelBooking, addBusiness, updateBusiness, fetchBusinessById, getBusinessForOwner }}>
      {children}
    </AppContext.Provider>
  );
};